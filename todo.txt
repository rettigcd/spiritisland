==== What I learned ====
Using execution context to create ActionScope unit-of-work
Using execution context to store GameState to avoid passing to everything.
Tokens (visible) & Mods (invisible) are placed on space and implement various behaviors like Imodify adding/removing and IHandle Added/Removed
The basic way the engine using Async to wait on user input.

Use a SourceSelector (SpaceToken-Selector) that is highly configurable to specify what tokens an action is going to happen to.

Encapsulation is the King - if you can't change it, encapsulate it.
Try to avoid inheriting more than 1 level.  
Don't move specific rules into the base (that solves 1 problem).  Move generic rules into the base that solves many.
Override methods to change behavior.  Hook into events to augment (add to) behavior.
Instead of deriving a new class for every change.  Break the behavior into behavior objects and mix and match.

Single inheritance ===> Prefer Composition over Inheritance

Text + Action<T> creates SpiritActions and SpaceActions.  Commands that act on a context <T>.

In tests:  Start an async method, make the UI calls, then await the Task to complete before checking stuff.

async in parallel can choke off threads - xUnit - limit # of tests running in parallel using Collections




==== To Do ====

GATHER - Replace TokenGatherer (on SpaceState) with .GatherSource( beforeToken ) which returns a SourceSelector

INCARNA - Make SpiritPresence & Incana derive from SpaceToken
INCARNA - Should all SpiritPresence have nullable Incarna token property so we don't have to use: is IHaveIncarna ihi?
INCARNA - Add a Spirit-Presence tag that All Spirit Tokens (& Incarna) match against - so we can count Presence (Entwine the fates of all)

BIND - SelfCtx - do we need this for anything? just replace with Spirit

----------
----------

DAMAGE - Rename ctx.DamageInvaders(..) to DamageInvadersAsync(...)
DAMAGE - Make ctx.DamageInvaders(...) a shortcut to ctx.Group(Human.Invaders).DoDamageAsync(...);

ORIGIN - When Targetting a Space, Capture the Origin spaces and supply those with the TargetSpaceCtx so it doesn't need re-calculated. (ScorchingConvergence)

MOVE -  SpaceToken.Move => Take a Count.  Return the .After part of the TokenMoved result.

SPIRITACTION - Allow SpiritActions to have multiple Conditions.  Maybe adding the Condition wraps the original Command in a new Command so we don't have to build conditions into SpiritActions. This would allow us to add the encapsulate the condition in PlaugeShipsSaleToDistantPosts

SPACE-SELECTOR - Select A.Space - see all the ways this is done and see if we can simplify the call, like creating a SpaceSelector
SPACE-SELECTOR - Create a SpaceSelector class that manages selecting spaces. (SolidifyEchoesOfMajestyPast) - that way we don't have to call .Select(A Space) so many times and we can write the while loop once instead of everywhere.)

RENAME - Rename SpaceState to SpaceTokens
RENAME - TotalCount => Invaders.TotalCount, Dahan.CountAll, TokkenBinding.Count should all of the same Property Name since they mean the same thing => Maybe switch to .Sum (to match SpaceState.SumAny) or .Total 
REANME - Reanme SourceSelector to SpaceTokenSelector or maybe abreviate to TokenSelector
REANME - SpaceToken <=> Token
	- is there a Token class?  Would it be confusing to rename SpaceToken to Token?
	- would it be confusing if SpaceToken inherited IToken and ISpace? - I think it probably would be confusing.
	- If we renamed IToken to ITokenType, then Token could have { ITokenType Type, Space Space } and Token would mean a 'token in a space' which simplifies SpaceTokenSelector to TokenSelector

TOKENS-Shortcut - Remove ctx.XX shortcut to Tokens.XX bindings OR make everything that has a TargetSpaceCtx use it.
TOKENS-Shortcut - TargetSpaceCtx.RemoveBlight() maybe should be .Blight.RemoveAsync()

RANGE - 3 Types of .Range: (1) Spirit.PowerRange, (2) SpaceState.Range (3) Space.Range - make sure everything is using the correct one and see if we can reduce/rename the methods so it is easier to pick the correct one.


Finders presence tracks are all dorked up.

Need Generic Method for spirits to pay for stuff - in Parallel - not 1 spirit choosing for everyone.  (PLagueShipsSailToDistantPorts)

Check calls to xxx_OfAnyTag( tags...) and see how many need converted to SpaceToken and switch over to SpaceToken

is convenience-method SpaceState.HasInvaders() necessary?  Could we just call the OfTag stuff direclty

Test if FocusTheSunsRays will gather Incarna, I think it will.  And we can remove the !! marker.

Async-Enum Spirit - Select 1 - encapsulate selecting 0 or 1 spirits so that we can forEach them.  (ConsiderAHarmoniousNature)

TargetSpaceCtx.SelectTargetSpaceAsync returns a TargetSpaceCtx.  Remove this - it is confusing.  At least verify that it is being used correclty.

====================================
====================================

Aspects
NI: Adversayrs / Fear / Blight



Thoughts: Freezing
	- Invaders > make them Dream-Invaders
	- Dahan > Implement IStopDamage and IStopRemovable
	- Can we find a way to do away with the Is-Removable test?

Thoughts: Additional Tags For Presence 
	- ActsAsPresence - when powers interact with "presence"
	- LooksLikePresence - cylindrical presence token - night never be used
	- LooksLikeIncarna - Incarna token
	- Spirit - Presence/Incarna for a particular spirit



=========================
====  Clean Up Items  ====
==========================

Blight cards can be drawn better.

User Setting:
	Preloaded Token or not
Game Options
	Cast-down is Ocean or Sunk

When gathering multiple token types with multiple landing locations, just use the general Space location as central destination.

Cheat Menu - 
	Reclaim all cards, 
	Add Card To Hand, 
	+10 energy, 
	+5 of each elementt, 
	Return Blight to Card
	Activate Fear Card

For Multi Player
	== Option 1 == 
		when starting action, make copy of the tokens
		- each action get an incremental ID
		- operate on the copy
		- track spaces
		- when done, commit => if any (spaces,spirits?,cards?) have been modified since start, rollback.
    -- Option 2 --
		- when interacting with spaces, have space join the Action
		- spaces that are part of an action cannot be joined to another action.
		- visual indication of which spaces are joined so user can wait or not select them
		- ! need to watch for deadlocks

For Action => Move Finders Hook to Action-start - event

ManyMinds - Set out-of-band toggle on beasts, at start of action, make smart choices based on phase, then use user choice sync for powers

======

2 Change Cmd.PushUpTo1Presence Implement SourceSelector as a something-that-acts-on--ManyTokensAction Command, implement RemoveToken as a ManyTokensAction that removes whatever is fed to it.

3 Fear Cards - ARE TOO SLOW!  Paint them on a known BG color so we can keep corners.
3 UI - Cleanup Presence-Track image generation
3 UI - Tokens - Publish token events to the UI so that it can show token changing animation.
3 Review items that are PickSpace then Pick Token into a single pick-space-token step.

2 Consilidate GameState API - things that aren't data and have no theoretical state.
2 Review Presence events. Can they be removed by having Presence do action directly? Consolidate => Single PresenceOnBoardChanged event
2 UI - Clean up Token drawing and ownership - CachedImageDrawer - make it draw the images
2 Create a target-space preview, when hovering over cards

TokenCountDictionary.counts -> make private.
Make Spirit.ResolveActions private/protected.

Idea - UI - When cusororing over HotSpot, have selected item glow / highlight
Idea - All of the Stop Tokens are actually just Pre-Build, Pre-Explore, Pre-Ravage events/configures

=========================
===== Feature Focus =====
=========================
* 2 spirit game (but still 1 player)
* Mobile
	- Spirit's 3 controls
	- Island control with tokens
	- Invader cards
	- Power Cards
	- Fear pool / cards

Later: Events
Later: Scenarios
Later: Aspects

===============================

== Architecture ==
Run on Android
Multiplayer Network Play

== UI improvement ==
Event driven UI updates

== Verify ==
Visions of shifting Future - fix once we support events - use Randomizer so it is repeatable.
The Past Returns again - implement all spirits paying.

=====  Steam Updates  =============
provide insight as to what they have trouble with
https://store.steampowered.com/news/app/1236720
https://spiritislandwiki.com/index.php?title=Main_Page
http://nerdroomsoftware.com/apps/SpiritGuide/spirits.php


=====  Damage Pipeline - Notes  =====

When doing damage and destroying, call must go through Token, and then SpaceState so that each can intercept and modify behavior.
	Caller => Token.Destory => SpaceState.Remove(or Destroy) => Token-Event-Hooks(Adding/Removing Token & Token Added/Removed).

When not doing damage, assuming other actions behavior doesn't get modified, can call SpaceState.Remove directly. (just not for Destroying).

Dahan and Invader Bindings 
	* are sealed and cannot modify behavior
	* are just Large-Group Management objects and should delegate damage to the Token => SpaceState.Remove/Destroy

TODO:
	Change tokens that modify the .Destroy() behavior with interface that hooks into the IModifyTokenRemove interface.
		This would allow us to skip calling Token.Destroy if we wished, making that simply a convenience method.


--------

[Preselct town/explorer]
[Incarna]
Action(TargetSpaceCtx ){
	Cmd.Abduct(Human.Explorer_Town)
}

class AbductAtIncarna {
	Action(){
		// check
	}
}
