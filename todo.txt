=========================

	SPIRIT - HORIZON - Eyes Watch from the Trees
	SPIRIT - HORIZON - Fathomless Mud of the Swamp

	UI - Cast Down into the Briny Deep - TEST

5	Change SpaceDecision .Move .Push methods to use Move options
5	Bag - could create a space on the board to represent the bag - contain blight, Beast, Wilds, etc
5	Cleanup All the SelectAsync<> variants.

	Replace Dynamic Defend with visible tokens.
	Investigate if Bringer and Trickster's Special Rules can be implemented with Mod Tokens to simplify UI.

4	UI - Landscape layout
	UI - Display Card Images
	UI - Display Icons in Text (card descriptions)
	UI - Minor / Major deck
	UI - Select Element

3	BUG - If no Dahan, strife does not come off invaders

== Other Hooks ==
		public class BuildEngine {
			public event Func<Space, HumanToken, Task>? BuildComplete;
		}
		public class ExploreEngine {
			public event Func<GameState,Task>? ExploreForCardComplete;
			public event Func<Space,Task>? ExploredSpace;
		}
		public class Fear : IHaveMemento {
			public event Action<IFearCard>? CardActivated;
		}
		public class InvaderCard{
			CardRevealed
		}

		public InvaderBinding{
			event InvaderDamaged
		}

3	Spirit Details View during configure-new-game.

3	CONFIG - replay game

3	Spirit Hints (best boards, starting Growths, card plays)

	SPIRITS - Horizon Spirits
		HORIZON - Devouring Teeth Lurk Underfoot
		HORIZON - Rising Heat of Stone and Sand
		HORIZON - Sun-Bright Whirlwind

	SPIRITS - Aspects (new spirits)

		Memory - Mentor
		Memory - Intensify    (Challenge: Hook into every action)

===== Clean Up =======

5	nullable enable

5	Sharp Fangs > Icon
5	Simplify TokenMover

4	Move general-purpose SpiritActions into a SpiritActions folder
4	Move Extension methods into their own namespaces so user can opt-in
4	Review Tests and get rid of the TestFixtureSetup

3	Rename Innate Options Methods
3	Setup-Action for spirit > Move to Spirit (Ocean & Fangs - give better name).
3	Switch Empowered Incarna markers to use the '+' icon or indicate empowered.

2	Remove Dynamic Defends

==== Maui questions / Problems ====

Why is it better to show/hide popups instead of re-creating them?

Slide-In - how to do it?

MVVM threading - best practice
	> When button click, model runs on UI thread
	> when model has event, thread is marshaled to UI thread.


Landscape vs Portrait - different Views?

Derived types in an enumeratoins.

When are pages torn down and rebuilt when switching pages?


==== What I learned ====
Using execution context to create ActionScope unit-of-work
Using execution context to store GameState to avoid passing to everything.
Tokens (visible) & Mods (invisible) are placed on space and implement various behaviors like Imodify adding/removing and IHandle Added/Removed
The basic way the engine using Async to wait on user input.

Use a SourceSelector (SpaceToken-Selector) that is highly configurable to specify what tokens an action is going to happen to.

Encapsulation is the King - if you can't change it, encapsulate it.
Try to avoid inheriting more than 1 level.  
Don't move specific rules into the base (that solves 1 problem).  Move generic rules into the base that solves many.
Override methods to change behavior.  Hook into events to augment (add to) behavior.
Instead of deriving a new class for every change.  Break the behavior into behavior objects and mix and match.

Single inheritance ===> Prefer Composition over Inheritance

Text + Action<T> creates SpiritActions and SpaceActions.  Commands that act on a context <T>.

In tests:  Start an async method, make the UI calls, then await the Task to complete before checking stuff.

async in parallel can choke off threads - xUnit - limit # of tests running in parallel using Collections

==== Notes to Developers ====
When the game throws an exception, it will appear in the game Log.   Don't click a UI option again or it will lock up and you can't see it.


==== Gems ====
* GameState.Current
* ActionScope
* Token Event Handlers: IModify[Adding|Removing][|Async], IHandleToken[Added|Removed]
* SourceSelector
* IActOn<T> derivative actions
* Adversary Levels

==== Lemons ====
How Spirits make Selections (too many mismatched options)
Game-wide config
The Invader Deck
InvaderBinding and Invader damage
Absolute Stasis
Powers that Prevent Dahan Damage or Invader Damage
.Rewind()
How the Pusher is confluently configured. :(

==== Quirks ====
Always use the < or <= sign, never the > or >= sign.

=====  Damage Pipeline - Notes  =====

When doing damage and destroying, call must go through Token, and then Space so that each can intercept and modify behavior.
	Caller => Token.Destory => Space.Remove(or Destroy) => Token-Event-Hooks(Adding/Removing Token & Token Added/Removed).

When not doing damage, assuming other actions behavior doesn't get modified, can call Space.Remove directly. (just not for Destroying).

Dahan and Invader Bindings 
	* are sealed and cannot modify behavior
	* are just Large-Group Management objects and should delegate damage to the Token => Space.Remove/Destroy

==== To Do ====

GATHER - Replace TokenGatherer (on Space) with .GatherSource( beforeToken ) which returns a SourceSelector
PUSH - Instead of custom TokenPushers - break into pieces and customize only  (# pushed) (PushDestinations)
Add ActionScope Run-At-Max hook for converting Present.Done to Present.Always for Trickster

==========

RANGE - 3 Types of .Range: (1) Spirit.PowerRange, (2) Space.Range (3) Space.Range - make sure everything is using the correct one and see if we can reduce/rename the methods so it is easier to pick the correct one.
DAMAGE - Make ctx.DamageInvaders(...) a shortcut to ctx.Group(Human.Invaders).DoDamageAsync(...);
TOKENS-Shortcut - Remove ctx.XX shortcut to Tokens.XX bindings OR make everything that has a TargetSpaceCtx use it.
TOKENS-Shortcut - TargetSpaceCtx.RemoveBlight() maybe should be .Blight.RemoveAsync()
Check calls to xxx_OfAnyTag( tags...) and see how many need converted to SpaceToken and switch over to SpaceToken
is convenience-method Space.HasInvaders() necessary?  Could we just call the OfTag stuff direclty
Async-Enum Spirit - Select 1 - encapsulate selecting 0 or 1 spirits so that we can forEach them.  (ConsiderAHarmoniousNature)

=========================
====  Clean Up Items  ====
==========================

For Multi Player
	== Option 1 == 
		when starting action, make copy of the tokens
		- each action get an incremental ID
		- operate on the copy
		- track spaces
		- when done, commit => if any (spaces,spirits?,cards?) have been modified since start, rollback.
    -- Option 2 --
		- when interacting with spaces, have space join the Action
		- spaces that are part of an action cannot be joined to another action.
		- visual indication of which spaces are joined so user can wait or not select them
		- ! need to watch for deadlocks

For Action => Move Finders Hook to Action-start - event

ManyMinds - Set out-of-band toggle on beasts, at start of action, make smart choices based on phase, then use user choice sync for powers

=========================
===== Feature Focus =====
=========================
* 2 spirit game (but still 1 player)

== Architecture ==
Multiplayer Network Play

== UI improvement ==
Event driven UI updates

== Verify ==
Visions of shifting Future - fix once we support events - use Randomizer so it is repeatable.
The Past Returns again - implement all spirits paying.

=====  Steam Updates  =============
provide insight as to what they have trouble with
https://store.steampowered.com/news/app/1236720
https://spiritislandwiki.com/index.php?title=Main_Page
http://nerdroomsoftware.com/apps/SpiritGuide/spirits.php
