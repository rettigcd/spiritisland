==== What I learned ====
Using execution context to create ActionScope unit-of-work
Using execution context to store GameState to avoid passing to everything.
Tokens (visible) & Mods (invisible) are placed on space and implement various behaviors like Imodify adding/removing and IHandle Added/Removed
The basic way the engine using Async to wait on user input.

Use a SourceSelector (SpaceToken-Selector) that is highly configurable to specify what tokens an action is going to happen to.

Encapsulation is the King - if you can't change it, encapsulate it.
Try to avoid inheriting more than 1 level.  
Don't move specific rules into the base (that solves 1 problem).  Move generic rules into the base that solves many.
Override methods to change behavior.  Hook into events to augment (add to) behavior.
Instead of deriving a new class for every change.  Break the behavior into behavior objects and mix and match.

Single inheritance ===> Prefer Composition over Inheritance

Text + Action<T> creates SpiritActions and SpaceActions.  Commands that act on a context <T>.

In tests:  Start an async method, make the UI calls, then await the Task to complete before checking stuff.

async in parallel can choke off threads - xUnit - limit # of tests running in parallel using Collections

==== Notes to Developers ====
When the game throws an exception, it will appear in the game Log.   Don't click a UI option again or it will lock up and you can't see it.


==== Gems ====
* GameState.Current
* ActionScope
* Token Event Handlers: IModify[Adding|Removing][|Async], IHandleToken[Added|Removed]
* SourceSelector
* IActOn<T> derivative actions
* Adversary Levels

==== Lemons ====
How Spirits make Selections (too many mismatched options)
Saving .SpaceState vs .Space
Game-wide config
The Invader Deck
InvaderBinding and Invader damage
Absolute Stasis
Powers that Prevent Dahan Damage or Invader Damage
.Rewind()
How the Pusher is confluently configured. :(

==== Quirks ====
Always use the < or <= sign, never the > or >= sign.

=====  Damage Pipeline - Notes  =====

When doing damage and destroying, call must go through Token, and then SpaceState so that each can intercept and modify behavior.
	Caller => Token.Destory => SpaceState.Remove(or Destroy) => Token-Event-Hooks(Adding/Removing Token & Token Added/Removed).

When not doing damage, assuming other actions behavior doesn't get modified, can call SpaceState.Remove directly. (just not for Destroying).

Dahan and Invader Bindings 
	* are sealed and cannot modify behavior
	* are just Large-Group Management objects and should delegate damage to the Token => SpaceState.Remove/Destroy

==== To Do ====

GATHER - Replace TokenGatherer (on SpaceState) with .GatherSource( beforeToken ) which returns a SourceSelector
PUSH - Instead of custom TokenPushers - break into pieces and customize only  (# pushed) (PushDestinations)
Add ActionScope Run-At-Max hook for converting Present.Done to Present.Always for Trickster

==========

RANGE - 3 Types of .Range: (1) Spirit.PowerRange, (2) SpaceState.Range (3) Space.Range - make sure everything is using the correct one and see if we can reduce/rename the methods so it is easier to pick the correct one.
DAMAGE - Make ctx.DamageInvaders(...) a shortcut to ctx.Group(Human.Invaders).DoDamageAsync(...);
TOKENS-Shortcut - Remove ctx.XX shortcut to Tokens.XX bindings OR make everything that has a TargetSpaceCtx use it.
TOKENS-Shortcut - TargetSpaceCtx.RemoveBlight() maybe should be .Blight.RemoveAsync()
Check calls to xxx_OfAnyTag( tags...) and see how many need converted to SpaceToken and switch over to SpaceToken
is convenience-method SpaceState.HasInvaders() necessary?  Could we just call the OfTag stuff direclty
Async-Enum Spirit - Select 1 - encapsulate selecting 0 or 1 spirits so that we can forEach them.  (ConsiderAHarmoniousNature)

=========================
====  Clean Up Items  ====
==========================

For Multi Player
	== Option 1 == 
		when starting action, make copy of the tokens
		- each action get an incremental ID
		- operate on the copy
		- track spaces
		- when done, commit => if any (spaces,spirits?,cards?) have been modified since start, rollback.
    -- Option 2 --
		- when interacting with spaces, have space join the Action
		- spaces that are part of an action cannot be joined to another action.
		- visual indication of which spaces are joined so user can wait or not select them
		- ! need to watch for deadlocks

For Action => Move Finders Hook to Action-start - event

ManyMinds - Set out-of-band toggle on beasts, at start of action, make smart choices based on phase, then use user choice sync for powers

=========================
===== Feature Focus =====
=========================
* 2 spirit game (but still 1 player)

== Architecture ==
Run on Android
Multiplayer Network Play

== UI improvement ==
Event driven UI updates

== Verify ==
Visions of shifting Future - fix once we support events - use Randomizer so it is repeatable.
The Past Returns again - implement all spirits paying.

=====  Steam Updates  =============
provide insight as to what they have trouble with
https://store.steampowered.com/news/app/1236720
https://spiritislandwiki.com/index.php?title=Main_Page
http://nerdroomsoftware.com/apps/SpiritGuide/spirits.php
