
Switch EVERY SourceSelector use to a await foreach(...)
Convert any while(...) that has a Selector at the start to an async-enumerable (Reach From the Infinite Darkness)
Make SourceSelector implement IAsyncEnumerable<T> - https://learn.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8

-- Ravage --
Add a convenience method = SpaceState.SkipInvaderAction => new SkipAnyInvaderAction(...)
Create a ConfigureRavage does all of the sit-outs.
Create an IConfigureRavage that does not stop the ravage and goes after the Skip-Ravage have been evaluated. (TerrifyingRampage)
Group All Sit-Out ravage-mods together an make generic so we don't need a different token-class foreach one.  (ExhaleConfusionAndDelirium)
Skip1InvaderAction - use new Token.SkipInvaderAction()

TokenAdded => SpaceToken .After
TokenRemoved => SpaceToken .Before
TokenMoved => SpaceToken .After .Before
Tokens.AddAsync should return the token that was added as a SpaceToken - incase it was modified while adding.
Rename SpaceState.Add(...) to SpaceState.AddAsync(...)

TargetSpaceCtx.AddStrife needs to be Async AND take a count.  (Terror Of the Hunted)

* Create an IEnumerable-Async method that selects spaces and allows user to select .Done to stop - (EarthShuddersBuildingsFall)

Warn of Impending Conflict - imp using Ravage-Config, not ISkipRavages

Move Growths out of Spirit folder into common SpiritAction folder.

Maybe pull the .SkipX methods on SpaceState extension methods since they don't need access to use internal state and are just for convenience

When Targetting a Space, Capture the Origin spaces and supply those with the TargetSpaceCtx so it doesn't need re-calculated. (ScorchingConvergence)



----------
----------

Finders presence tracks are all dorked up.

Select A.Space - see all the ways this is done and see if we can simplify the call, like creating a SpaceSelector

BindXXX() - combine into a single method
SelfCtx - do we need this for anything? just replace with Spirit

SpaceToken.Move => Take a Count.  Return the .After part of the TokenMoved result.

TotalCount => Invaders.TotalCount, Dahan.CountAll, TokkenBinding.Count should all of the same Property Name since they mean the same thing => Maybe switch to .Sum (to match SpaceState.SumAny) or .Total 

Rebrand things under the Growth folder as SpiritAction.
	- No growth action should implement IActionFactory directly, should all come as SpiritActions that get wrapped.

All InvaderBinding.UserSelectedDamage methods should take a SourceSelector

Reanme SourceSelector to SpaceTokenSelector or maybe abreviate to TokenSelector

SpaceToken <=> Token
- is there a Token class?  Would it be confusing to rename SpaceToken to Token?
- would it be confusing if SpaceToken inherited IToken and ISpace? - I think it probably would be confusing.
- If we renamed IToken to ITokenType, then Token could have { ITokenType Type, Space Space } and Token would mean a 'token in a space' which simplifies SpaceTokenSelector to TokenSelector

TokenPusher -> when pushing from Multiple lands, need a way to Implement on SpaceState.Pusher

Rename SpaceState to SpaceTokens

Remove ctx.XX shortcut to Tokens.XX bindings OR make everything that has a TargetSpaceCtx use it.

RemoveAll - (FragmensOfYesterYear) - could pass a TokenSelector to A Remove-All method
	- Remove-All would get all options, not asking user to select individuals.

If we could late-bind TokenMover, then it would act more like a Command.

Should RemoveUpToNHealthOfInvaders be put in an InvaderCmd space or a RemoveCmd space ???

TargetSpaceCtx.RemoveBlight() maybe should be .Blight.RemoveAsync()

Add SourceSelector constructor that does a Power-Range option from Target (InspireTheReleaseOfStolenLand)

Change the TokenMove.Filters to .ConfigFilter or .ConfigDestination()

Allow SpiritActions to have multiple Conditions.  Maybe adding the Condition wraps the original Command in a new Command so we don't have to build conditions into SpiritActions. This would allow us to add the encapsulate the condition in PlaugeShipsSaleToDistantPosts

Need Generic Method for spirits to pay for stuff - in Parallel - not 1 spirit choosing for everyone.  (PLagueShipsSailToDistantPorts)

3 types of .Range: (1) Spirit.PowerRange, (2) SpaceState.Range (3) Space.Range - make sure everything is using the correct one and see if we can reduce/rename the methods so it is easier to pick the correct one.

Instead of calling TargetSpaceCtx.Push(...), maybe we should create a Quota and/or SourceSelector and call .Push(UpTo)N() on it. 
	- THEN when we call .Push() we could pass an optional Filter instead of having to call .FilterDestination() before the push.

Rename ctx.DamageInvaders(..) to DamageInvadersAsync(...)

Make ctx.DamageInvaders(...) a shortcut to ctx.Group(Human.Invaders).DoDamageAsync(...);

Move DamageInvaderExtesnsion closer to the Invaders binding or into the Extensions folder.

Create a SpaceSelector class that manages selecting spaces. (SolidifyEchoesOfMajestyPast) - that way we don't have to call .Select(A Space) so many times and we can write the while loop once instead of everywhere.)

Destroying presence simplified into a SourceSelector followed by .DoDestroy(N)   (TransformativeSacrifice and probably others)

??? Are InvadersBinding just a fancy SourceSelector that includes all invaders on a space?
	??? Are Dahan Bindings just a fancy SourceSelector that includes all dahan?  
	??? Tokens?

Make SpiritPresence & Incana derive from SpaceToken

Check calls to xxx_OfAnyTag( tags...) and see how many need converted to SpaceToken and switch over to SpaceToken

Incarna and SpiritPresenceTokens should have .Spirit prop pointing back to Spirit (Reach from the infinite Darkness)

SourceSelector can support both user-selected and select-all.  
	Opt 1 
		- Create a .UserSelectAsync(Spirit,Prompt,Present.Done) that allows user to select
		- Create a .All() that returns all of the items
	Opt 2
		- Add a .ConfigureReturnAll() - this option Sucks!  Use option 1.

Chaining - Create a .ForEachAsync(...) extension that either returns Task or Task<IEnumerable>... to allow something like this:
		await ctx.Tokens.SpaceTokensOfTag(Human.Explorer)
			.PickN( 1, "Abduct Explorer" Present.Always )
			.ForEachAsync( st => st.MoveTo(..) )
			.ForEachAsync( st => Act2(action) );

Should all SpiritPresence have nullable Incarna token property so we don't have to use: is IHaveIncarna ihi?

If SourceSelector had an enumerator that takes IEnumerable<SpaceToken>, would simplify conversion between that and SourceSelector. - maybe / maybe not - is it necessary?

ReplaceInvader.DowngradeXXX could take a SourceSelector instead of hard coded.

Create a TokenSelector.Bind(TargetSpaceCtx).IEnumerable ==> Action

* Compose Actions via 
	Pick(1,Group)
		.Plus(2,Group)
		.From( spaces )
		.Push
		.To( spaces )
		.AllDifferent()
		.DoAll()

* Combine Spirit.BindXXX methods into 1

is convenience-method SpaceState.HasInvaders() necessary?  Could we just call the OfTag stuff direclty

Test if FocusTheSunsRays will gather Incarna, I think it will.  And we can remove the !! marker.

UnbearableGaze - Pusher does not use SpaceState.Pusher (because it works on multiple spaces.)

Async-Enum Spirit - Select 1 - encapsulate selecting 0 or 1 spirits so that we can forEach them.  (ConsiderAHarmoniousNature)

Add a Spirit-Presence tag that All Spirit Tokens (& Incarna) match against - so we can count Presence (Entwine the fates of all)

Could switch TokenRemover to combo: SourceSelector.DoRemove()  (Radiant And Hallowed Grove)

Cmd.RemoveNTokens - could use combo: SourceSelector and .DoRemove()

TokenStrifer class - use SourceSelector as Async enumerable - see if class simplifies away to nothing.

TargetSpaceCtx.SelectTargetSpaceAsync returns a TargetSpaceCtx.  Remove this - it is confusing.  At least verify that it is being used correclty.

Can TokenMover be broken apart into enumerable and Action so that we can interact directly with item return, instead of hadding Hook for TokenMoved










====================================
====================================

Aspects
NI: Adversayrs / Fear / Blight



Thoughts: Freezing
	- Invaders > make them Dream-Invaders
	- Dahan > Implement IStopDamage and IStopRemovable
	- Can we find a way to do away with the Is-Removable test?

Thoughts: Additional Tags For Presence 
	- ActsAsPresence - when powers interact with "presence"
	- LooksLikePresence - cylindrical presence token - night never be used
	- LooksLikeIncarna - Incarna token
	- Spirit - Presence/Incarna for a particular spirit



=========================
====  Clean Up Items  ====
==========================

Blight cards can be drawn better.

User Setting:
	Preloaded Token or not
Game Options
	Cast-down is Ocean or Sunk

When gathering multiple token types with multiple landing locations, just use the general Space location as central destination.

Cheat Menu - 
	Reclaim all cards, 
	Add Card To Hand, 
	+10 energy, 
	+5 of each elementt, 
	Return Blight to Card
	Activate Fear Card

For Multi Player
	== Option 1 == 
		when starting action, make copy of the tokens
		- each action get an incremental ID
		- operate on the copy
		- track spaces
		- when done, commit => if any (spaces,spirits?,cards?) have been modified since start, rollback.
    -- Option 2 --
		- when interacting with spaces, have space join the Action
		- spaces that are part of an action cannot be joined to another action.
		- visual indication of which spaces are joined so user can wait or not select them
		- ! need to watch for deadlocks

For Action => Move Finders Hook to Action-start - event

ManyMinds - Set out-of-band toggle on beasts, at start of action, make smart choices based on phase, then use user choice sync for powers

======

2 Change Cmd.PushUpTo1Presence Implement SourceSelector as a something-that-acts-on--ManyTokensAction Command, implement RemoveToken as a ManyTokensAction that removes whatever is fed to it.

3 Fear Cards - ARE TOO SLOW!  Paint them on a known BG color so we can keep corners.
3 UI - Cleanup Presence-Track image generation
3 UI - Tokens - Publish token events to the UI so that it can show token changing animation.
3 Review items that are PickSpace then Pick Token into a single pick-space-token step.

2 Consilidate GameState API - things that aren't data and have no theoretical state.
2 Review Presence events. Can they be removed by having Presence do action directly? Consolidate => Single PresenceOnBoardChanged event
2 UI - Clean up Token drawing and ownership - CachedImageDrawer - make it draw the images
2 Create a target-space preview, when hovering over cards

TokenCountDictionary.counts -> make private.
Make Spirit.ResolveActions private/protected.

Idea - UI - When cusororing over HotSpot, have selected item glow / highlight
Idea - All of the Stop Tokens are actually just Pre-Build, Pre-Explore, Pre-Ravage events/configures

=========================
===== Feature Focus =====
=========================
* 2 spirit game (but still 1 player)
* Mobile
	- Spirit's 3 controls
	- Island control with tokens
	- Invader cards
	- Power Cards
	- Fear pool / cards

Later: Events
Later: Scenarios
Later: Aspects

===============================

== Architecture ==
Run on Android
Multiplayer Network Play

== UI improvement ==
Event driven UI updates

== Verify ==
Visions of shifting Future - fix once we support events - use Randomizer so it is repeatable.
The Past Returns again - implement all spirits paying.

=====  Steam Updates  =============
provide insight as to what they have trouble with
https://store.steampowered.com/news/app/1236720
https://spiritislandwiki.com/index.php?title=Main_Page
http://nerdroomsoftware.com/apps/SpiritGuide/spirits.php


=====  Damage Pipeline - Notes  =====

When doing damage and destroying, call must go through Token, and then SpaceState so that each can intercept and modify behavior.
	Caller => Token.Destory => SpaceState.Remove(or Destroy) => Token-Event-Hooks(Adding/Removing Token & Token Added/Removed).

When not doing damage, assuming other actions behavior doesn't get modified, can call SpaceState.Remove directly. (just not for Destroying).

Dahan and Invader Bindings 
	* are sealed and cannot modify behavior
	* are just Large-Group Management objects and should delegate damage to the Token => SpaceState.Remove/Destroy

TODO:
	Change tokens that modify the .Destroy() behavior with interface that hooks into the IModifyTokenRemove interface.
		This would allow us to skip calling Token.Destroy if we wished, making that simply a convenience method.


--------

[Preselct town/explorer]
[Incarna]
Action(TargetSpaceCtx ){
	Cmd.Abduct(Human.Explorer_Town)
}

class AbductAtIncarna {
	Action(){
		// check
	}
}
